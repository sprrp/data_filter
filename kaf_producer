from confluent_kafka import Producer, KafkaError
import concurrent.futures

def kafka_producer_setup():
    # SSL configuration (replace with your SSL settings)
    ssl_config = {
        'security.protocol': 'ssl',
        'ssl.ca.location': '/path/to/ca_certificate.pem',
        'ssl.certificate.location': '/path/to/client_certificate.pem',
        'ssl.key.location': '/path/to/client_key.pem',
    }

    # Kafka producer configuration
    producer_config = {
        'bootstrap.servers': 'kafka_broker1:9093,kafka_broker2:9093',  # Replace with your Kafka broker addresses
        'group.id': 'my_group',  # Optional consumer group ID if you need one
        'security.protocol': 'ssl',
        'ssl.ca.location': '/path/to/ca_certificate.pem',
        'ssl.certificate.location': '/path/to/client_certificate.pem',
        'ssl.key.location': '/path/to/client_key.pem',
    }

    # Create the Kafka producer
    producer = Producer(producer_config, ssl_context=ssl_config)
    return producer

def send_message(producer, topic, message):
    def delivery_callback(err, msg):
        if err is not None:
            print(f"Message delivery failed: {err}")
        else:
            print(f"Message delivered to {msg.topic()} [{msg.partition()}] at offset {msg.offset()}")

    try:
        # The produce method does not block, so we use ThreadPoolExecutor to wait for its completion with a timeout.
        with concurrent.futures.ThreadPoolExecutor() as executor:
            future = executor.submit(producer.produce, topic, message.encode('utf-8'), callback=delivery_callback)
            result = future.result(timeout=2)  # Wait for 2 seconds for the produce call to complete

        if result is None:
            print("Message delivery timed out.")
            # Optionally, you can try to cancel the producer call here if required.
        else:
            print("Message delivered successfully.")
    except concurrent.futures.TimeoutError:
        print("Message delivery timed out.")
        # Optionally, you can try to cancel the producer call here if required.
    except KafkaError as e:
        print(f"Failed to send message: {e}")

if __name__ == "__main__":
    kafka_producer = kafka_producer_setup()
    topic_name = "your_topic"
    message_to_send = "Hello, Kafka!"

    send_message(kafka_producer, topic_name, message_to_send)

    kafka_producer.flush()  # Flush any remaining messages before closing the producer
    kafka_producer.close()
